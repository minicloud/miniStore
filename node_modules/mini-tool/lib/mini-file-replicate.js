
var util          = require('util'); 
var EventEmitter  = require('events').EventEmitter; 
var MiniFileUtils = require('./mini-file-utils').MiniFileUtils;
var miniFileUtils = new MiniFileUtils(); 
var http          = require('http');
var fs            = require('fs');
var crypto        = require('crypto');

http.globalAgent.maxSockets=100;

function MiniFileReplicate(client,config,logger,task,callback){
	EventEmitter.call(this); 
	var storeNodeName  = config.name; 
	this.pathList      = config.path;
	this.hKey          = storeNodeName+"_replicateList";  
	this.client        = client;
	this.nextCallback  = callback;
	this.logger        = logger;
	var self = this;
	this.callbackFunction = function(){
		client.rpop(self.hKey, self.nextCallback);
	}
	this.size          = task.size;
	this.signature     = task.signature;
	this.downloadUrl   = task.downloadUrl;
	this.callbackUrl   = task.callbackUrl;
	this.normalPath    = miniFileUtils.getFileContentNormalPath(this.pathList,this.signature,this.size);
	

}
exports.MiniFileReplicate = MiniFileReplicate;
util.inherits(MiniFileReplicate, EventEmitter);
//下载文件
MiniFileReplicate.prototype.run = function(){
	var self = this; 
	try{
		//如已存在文件，执行回调函数，并进行下一个任务
		if(fs.existsSync(self.normalPath)){ 
			//调用回调地址
	        http.get(self.callbackUrl, function (res) { 
				if(res.statusCode==200){
					self.logger.info({"replicate callback url success":self.callbackUrl});	
				}else{
					self.logger.error({"replicate callback url error":self.callbackUrl,"status":res.statusMessage});		
				}
				self.callbackFunction(); 
			});
			return;  
		}

        self.logger.info({"replicate":self.downloadUrl});
		//下载文件
		http.get(self.downloadUrl, function(res) {
			if(res.statusCode==200){
				self.download(res);
			}else if(res.statusCode==301){
				//支持迷你存储
				var url = res.headers.location;
				http.get(url, function(res) {
					if(res.statusCode==200){
						self.download(res);
					}else{
						self.logger.error({"url":url,"msg":res.statusMessage});
						self.callbackFunction(); 
					} 
				});
			}else{
				self.logger.error({"url":self.downloadUrl,"msg":res.statusMessage});
				self.callbackFunction(); 
			}
		});
	}catch(error){
		self.logger.error({"url":self.downloadUrl,"error":error});
		self.callbackFunction(); 
	}
}
//下载文件
MiniFileReplicate.prototype.download = function(res){
	var self = this; 
	var folderPath = require('path').dirname(self.normalPath);
    if(!fs.existsSync(folderPath)){
	    //创建存储路径
	    var mkdirp = require('mkdirp');
	    mkdirp.sync(folderPath);
    }
    //临时文件默认为上一次临时文件位置，避免存储空间反复存储不同类型的文件
    var tempFilePath = self.normalPath+"_cache_replicate";
    var cachePath = miniFileUtils.getFileContentNormalPath(this.pathList,this.signature,this.size,"_cache_replicate");
    //删除此前的缓存文件
    if(fs.existsSync(cachePath)){
        tempFilePath = cachePath;
    }
    //写入临时文件
    var writeFile    = fs.createWriteStream(tempFilePath, {'flags': 'w'});
	res.pipe(writeFile);
	res.on('end', function () {
		if(fs.existsSync(tempFilePath)) {
			//计算文件hash值是否是期望值
            var shaSum = crypto.createHash('sha1');
            var stream = fs.ReadStream(tempFilePath);
            stream.on('data', function(d) {
                shaSum.update(d);
            });
            stream.on('end', function() {
            	var oriSignature = require('path').basename(self.normalPath);
                var newSignature = shaSum.digest('hex');
                if(oriSignature==newSignature){
                	//把临时文件重新命名为正式文件
					fs.renameSync(tempFilePath,self.normalPath); 
	                //调用回调地址
	                http.get(self.callbackUrl, function (res) {
                        if(res.statusCode==200){
                        	self.logger.info({"replicate callback url success":self.callbackUrl});
						}else{
							self.logger.error({"replicate callback url error":self.callbackUrl,"status":res.statusMessage});
						}
                        self.callbackFunction();
                    });
                }else{
                	self.logger.error("signature invalid "+tempFilePath+" s:"+newSignature+" expect:"+oriSignature);
                    self.callbackFunction();
                }
            });
		}
                           
	}); 
}