var path        = require('path');
var fs          = require('fs');

var MiniFileUtils=function(){
	
};
var CacheFileKey = "_cache";
/**
* 产生随机数
*/
MiniFileUtils.prototype.getRandomNum=function(Min,Max)
{   
	var Range = Max - Min;   
	var Rand = Math.random();   
	return(Min + Math.round(Rand * Range));   
}  
/**
* 获得存储文件路径
* 可选目录列表中寻找随机可存储目标文件目录，如都不能存储，则返回错误
* @param zonePathList 可存储文件的目录列表
* @param signature 文件sha1 
*/
MiniFileUtils.prototype.getFileContentPathAsync=function(zonePathList,signature,callback){
    var self = this;
    //循环分区，查询该分区下是否有指定文件
    var k = 0;
    (function nextZone(){
        if(k>=zonePathList.length){
            //指定分区查询后都没有发现
            callback("");
            return;
        }
        var zonePath  = zonePathList[k];
        var maybePath = self._getFileContentPath(zonePath,signature);
        if(fs.existsSync(maybePath)){
            //兼容迷你存储老数据存储，它把文件进行分块处理
            //老数据格式如下
            //signature
            //signature0001
            //signature0002
            //先把分块的文件进行合并为完整文件，然后输出
            var stat = fs.statSync(maybePath);
            if(stat.isDirectory()){
                var newFilePath = path.join(maybePath,"new_"+signature);
                if(fs.existsSync(newFilePath)){
                    //迷你存储1.0存储格式，合并后的新文件返回路径
                    callback(newFilePath);
                    return;
                }
                var subFiles = fs.readdirSync(maybePath);
                //查询子文件块，将其合并为完整文件
                var i=0;
                (function next() {
                    if(i>=subFiles.length){
                        //迷你存储1.0现场合并后，返回新文件路径
                        callback(newFilePath);
                        return;
                    }
                    var fileName = subFiles[i];
                    if(fileName.indexOf(signature)==0){
                        var itemFilePath = path.join(maybePath,fileName);
                        var writeStream  = fs.createWriteStream(newFilePath,{'flags': 'a'});
                        var readStream   = fs.createReadStream(itemFilePath);
                        readStream.pipe(writeStream);
                        readStream.on("end",function(){
                            i+=1;
                            next();
                        });
                    }else{
                        i+=1;
                        next();
                    }
                })();
            }else{
                //迷你存储2.0产生的新文件
                callback(maybePath);
                return;
            }

        }else{
            //循环下一个分区
            k++;
            nextZone();
        }
    })();

	
}
/**
* 获得临时文件存储路径
*/
MiniFileUtils.prototype.getCacheFileContentPath=function(pathList,signature,size){
	return this.getFileContentNormalPath(pathList,signature,size,extend=CacheFileKey);
}
/**
* 根据缓存文件路径获得正式文件路径
*/
MiniFileUtils.prototype.getFileContentNormalPath=function(pathList,signature,size,extend){
	if(typeof extend =="undefined"){
		extend = "";
	} 
	for(var i in pathList){
		var subPath = pathList[i]; 
		var maybePath = this._getFileContentPath(subPath,signature+extend);
        if(fs.existsSync(maybePath)){
        	return maybePath;
        }
    }
    //TODO 这里要对子目录的可用空间检查
    //TODO 判断目录是否有写权限
    //如不存在断点文件，则随机选择一个子目录进行文件存储
	var pos = this.getRandomNum(0,pathList.length-1);
    var subPath = pathList[pos]; 
	return this._getFileContentPath(subPath,signature+extend);
}
/**
* 把缓存文件重命名为正式文件
*/
MiniFileUtils.prototype.cache2Normal=function(cacheFilePath){
	var normalPath = cacheFilePath.substring(0,cacheFilePath.length-CacheFileKey.length);
	fs.renameSync(cacheFilePath,normalPath);
} 
/**
* 根据signature+rootPath获得访问该文件的路径
*/
MiniFileUtils.prototype._getFileContentPath=function(rootPath,signature){
	var sub1 = signature.substring(0,2);
	var sub2 = signature.substring(2,4);
	var sub3 = signature.substring(4,6);
	var sub4 = signature.substring(6,8);
	return path.join(rootPath,sub1,sub2,sub3,sub4,signature);
}
exports.MiniFileUtils = MiniFileUtils;