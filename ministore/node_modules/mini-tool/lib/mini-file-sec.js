var util          = require('util');
var EventEmitter  = require('events').EventEmitter;
var MiniFileUtils = require('./mini-file-utils').MiniFileUtils;
var fs            = require("fs");
/**
* 文件秒传，先判断目标路径下的文件夹里是否包含了目标文件
* 如存在则向迷你云回调地址发送报俊信息
* 否则查询是否有临时文件存在，如有临时文件返回已上传的文件块信息
* 否则为文件生成空文件，返回空的文件块信息
**/
function MiniFileSec(miniHttp){
	EventEmitter.call(this);
    var self          = this;
	this.pathList     = miniHttp.appConfig.path;
	var signature     = miniHttp.queryParam("signature","");
	var size          = parseInt(miniHttp.queryParam("size",0));
    var miniFileUtils = new MiniFileUtils();
	var secFile       = function(filePath){
		if(filePath!='' && fs.existsSync(filePath)){
			var callbackUrl = miniHttp.queryParam("callback","");
			var successCallback = function(data){
				var responseData = {
					code:200,
					data:data
				};				
				miniHttp.response(responseData);
			};
			var errorCallback = function(data){
				var responseData = {
					code:401,
					data:data
				};				
				miniHttp.response(responseData);
			};
			miniHttp.createRequest(callbackUrl,[],successCallback,errorCallback); 
		}else{
			//获得缓存文件地址
			//如缓存文件已存在，判断缓存是否与预期一致，如则返回断点文件信息。
			var cacheFilePath = miniFileUtils.getCacheFileContentPath(self.pathList,signature,size);
			var cacheSize     = 0;
			if(fs.existsSync(cacheFilePath)){
				cacheSize     = fs.statSync(cacheFilePath).size;
			} 
			var responseData = {
				code:200,
				data:{
					success:false,
					offset:cacheSize
				}
			};				
			miniHttp.response(responseData); 
		}
    }
    //寻找已上传成功的文件
    miniFileUtils.getFileContentPathAsync(this.pathList,signature,secFile);
	
} 
exports.MiniFileSec = MiniFileSec;
util.inherits(MiniFileSec, EventEmitter);
